<?php
/**
 *  Router dispatcher generated by crodas/Dispatcher
 *
 *  https://github.com/crodas/Dispatcher
 *
 *  This is a generated file, do not modify it.
 */
#* if ($config->getNamespace()) 
#* $namespace = $config->getNamespace()
namespace __namespace__;
#* end

class NotFoundException extends \Exception 
{
}

class RouteNotFoundException extends \Exception 
{
}

interface FilterCache
{
    public function has($key);
    public function set($key, $value, $ttl);
    public function get($key);
}

class Request
{
    protected $var = array();
    protected $changes = array();
    protected $watch   = false;

    public function watchChanges()
    {
        $this->watch   = true;
        $this->changes = array();
        return true;
    }

    public function getChanges()
    {
        $this->watch = false;
        return $this->changes;
    }

    protected function handleNotFound()
    {
        $req = $this;
        #* render($self->getNotFoundHandler())

        return false;
    }

    public function notFound()
    {
        if ($this->handleNotFound() !== false) {
            /** 
             * Was it handled? Yes!
             */
            exit;
        }

        throw new NotFoundException;
    }

    public function setIfEmpty($name, $value)
    {
        if (empty($this->var[$name])) {
            $this->var[$name] = $value;
            if ($this->watch) {
                $this->changes[] = $name;
            }
        }
        return $this;
    }

    public function set($name, $value)
    {
        $this->var[$name] = $value;
        if ($this->watch) {
            $this->changes[] = $name;
        }
        return $this;
    }

    public function get($name)
    {
        if (array_key_exists($name, $this->var)) {
            return $this->var[$name];
        }
        return NULL;
    }
}

class Route
{
    protected $cache;

    public function setCache(FilterCache $cache)
    {
        $this->cache = $cache;
    }

    // doCachedFilter {{{
    /**
     *  Cache layer for Filters.
     *
     *  If a filter is cachable and a cache object is setup this method will
     *  cache the output of a filter (and all their modifications to a request).
     *
     *  This function is designed to help with those expensive filters which 
     *  for instance talks to databases.
     */
    protected function doCachedFilter($callback, Request $req, $key, $value, $ttl)
    {
        if (empty($this->cache)) {
            // no cache layer, we're just a proxy, call to the original callback
            if (is_string($callback)) {
                $return = $callback($req, $key, $value);
            } else {
                $return = $callback[0]->{$callback[1]}($req, $key, $value);
            }
            return $return;
        }

        $objid = "{$key}\n{$value}";
        if ($v=$this->cache->get($objid)) {
            $req->set('filter:cached:' . $key, true);
            $object = unserialize($v);
            foreach ($object['set'] as $key => $value) {
                $req->set($key, $value);
            }
            return $object['return'];
        }

        // not yet cached yet so we call the filter as normal
        // but we save all their changes it does on Request object
        $req->watchChanges();
        if (is_string($callback)) {
            $return = $callback($req, $key, $value);
        } else {
            $return = $callback[0]->{$callback[1]}($req, $key, $value);
        }
        $keys = $req->setIfEmpty($key, $value)->getChanges();
        $set  = array();
        foreach ($keys as $key) {
            $set[$key] = $req->get($key);
        }

        $this->cache->set($objid, serialize(compact('return', 'set')), 3600); 

        
        return $return;
    }
    // }}}

    public function fromRequest(Request $req = NULL)
    {
        if (empty($req)) {
            $req = new Request;
        }
        return $this->doRoute($req, $_SERVER);
    }

    #* foreach($self->getComplexUrls() as $i => $url)
    #   $route    = $url->getRouteDefinition()
    /** @Handler for __route___ */
    protected function complex_url___i__($req, $parts, $length, $server)
    {
        $i = 0;
        #* foreach ($url->getParts() as $part)
        #   $expr  = expr($part)
        #   if ($part->isRepetitive())

        // repetitive rule for __part__
            #* if ($expr)
        $vars = array();

        while (__expr__) {
            #* foreach ($part->getVariables('crodas') as $name => $var)
            #   if (count($var) == 1)
            #       $variable = "parts[$i]"
            #   else
            #       $variable = "matches_0[" . $var[1] . "]"
            #   end
                $vars[__@name__][] =  $__variable__;
            #* end
            ++$i;
        }

        foreach ($vars as $key => $value) {
            $req->set($key, $value);
        }
            #* end
        // end

        #*  else
        #*       if ($expr)
            if (!(__expr__)) {
                return false;
            }
            #* foreach ($part->getVariables('crodas') as $name => $var)
            #   if (count($var) == 1)
            #       $variable = "parts[$i]"
            #   else
            #       $variable = "matches_0[" . $var[1] . "]"
            #   end
                $req->set(__@name__, $__variable__);;
            #* end
        #*      end
            ++$i;
        #*   end
        #* end

        # foreach ($url->getArguments() as $name => $var)
        $req->set(__@name__, __@var__);
        #* end

        return true;
    }
    #* end

    protected function handleComplexUrl(Request $req, $parts, $length, $server)
    {
        #* foreach($self->getComplexUrls() as $i => $url)
        #   $mlength = $url->getMinLength()
        #   $consts  = $url->getConstants()
        #   $lconsts = count($consts)
        #   $cfirst  = $url->getFirstConstant()
        #   $clast   = $url->getLastConstant()
        $is_candidate = $length >= __@mlength__
        #* if ($cfirst)
            && $parts[0] == __@cfirst__
        #* end
        #* if ($clast)
            && $parts[$length-1] == __@clast__
        #* end
        #* if (count($consts) > 0)
            && count(array_intersect($parts, __@consts__)) == __@lconsts__
        #* end
            ;
        if ($is_candidate && $this->complex_url___i__($req, $parts, $length, $server) == true) {
            return true;
        }
        #* end
    throw new NotFoundException;
    }

    public function doRoute(Request $req, $server)
    {
        $uri    = $server['REQUEST_URI'];
        $uri    = ($p = strpos($uri, '?')) ? substr($uri, 0, $p) : $uri;
        $parts  = array_values(array_filter(explode("/", $uri)));
        $length = count($parts);

        if (empty($server['REQUEST_METHOD'])) {
            $server['REQUEST_METHOD'] = 'GET';
        }

        #* render($groups)

        #* render($self->getNotFoundHandler())
        
        // We couldn't find any handler for the URL,
        // let's find in our complex url set (if there is any)
        $this->handleComplexUrl($req, $parts, $length, $server);
    }

    public static function getRoute($name, $args = array())
    {
        if (!is_array($args)) {
            $args = func_get_args();
            array_shift($args);
        }

        $count = count($args);
        switch ($name) {
        #* 
        # foreach ($self->getNamedUrls() as $name => $route)
        case __@name__:
            #* $routes = $route['routes']
            #* $exception = $route['exception']
            #* foreach ($routes as $id => $url)
            #   $expr = $url->getRouteExpr()
            #   $filter = $url->getRouteFilter()
            if (__filter__) {
                return __expr__;
            }
            #* end

            throw new RouteNotFoundException("Invalid arguments for route __name__, possible routes:\n__exception__");

        #* end
        }

        throw new RouteNotFoundException("There is not route name $name");
    }
}
